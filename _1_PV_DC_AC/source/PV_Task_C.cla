//Ngay 10/4/2024 ghep noi bo AC Battery vong ap che do doc lap tai R = 64 Ohm
//Ngay 4/6/2024 ghep noi bo AC Battery vong ap che do doc lap tai dien tu R = 200 Ohm, giam xuong R = 100 Ohm va xuong R = 80 Ohm
//Code chuyen bo dieu khien va code che do bao ve moi do Luu Linh K65 code
//13/7/2024 Kp dong = 2.0; Ki dong = 0.18; Bao ve dong 15A; Chay AC Bat voi tai dien tu 1kW; Thoi gian chay 2 phut
#include "PV_Shared.h"

#pragma CODE_SECTION(Cla1Task1, "Cla1Prog");

/***************************************************************************/
// Variables used for computation on the CLA are in CLA writable space i.e. the CLA data RAM

#pragma DATA_SECTION(IsrTicker,"CLADataLS0");
volatile Uint32 IsrTicker;

//======================================================
#pragma DATA_SECTION(rg_har_1st,"CLADataLS0");
volatile RAMP_GEN_CLA rg_har_1st;

#pragma DATA_SECTION(Set_ramp,"CLADataLS0");
volatile RAMP_GEN_CLA Set_ramp;

//======================================================
// inverse park object for inverter reference voltages transformation
#pragma DATA_SECTION(ipark_voltref,"CLADataLS0");
volatile iPARK_CLA ipark_voltref;

//======================================================
#pragma DATA_SECTION(park_curr,"CLADataLS0");
volatile PARK_CLA park_curr;

// park object for load voltages
#pragma DATA_SECTION(park_volt,"CLADataLS0");
volatile PARK_CLA park_volt;

// park object for grid currents
#pragma DATA_SECTION(park_volt_pll,"CLADataLS0");
volatile PARK_CLA park_volt_pll;

//=======================================================
// clarke object for load voltages
#pragma DATA_SECTION(clarke_volt,"CLADataLS0");
volatile CLARKE_3PHASE_CLA clarke_volt;

// clarke object for grid currents
#pragma DATA_SECTION(clarke_curr,"CLADataLS0");
volatile CLARKE_3PHASE_CLA clarke_curr;

// clarke object for grid voltages transformation inside PLL module
#pragma DATA_SECTION(clarke_volt_pll,"CLADataLS0");
volatile CLARKE_3PHASE_CLA clarke_volt_pll;

//==================================
// PLL
#pragma DATA_SECTION(pll_3phase,"CLADataLS0");
volatile PLL_PHASE_CLA pll_3phase;

//=======================================================

// CONTROLLER
#pragma DATA_SECTION(pi_curr_id,"CLADataLS0");
volatile PI_NORMAL_CLA pi_curr_id;

#pragma DATA_SECTION(pi_curr_iq,"CLADataLS0");
volatile PI_NORMAL_CLA pi_curr_iq;

#pragma DATA_SECTION(pi_curr_iz,"CLADataLS0");
volatile PI_NORMAL_CLA pi_curr_iz;

#pragma DATA_SECTION(pi_volt_Udc,"CLADataLS0");
volatile PI_NORMAL_CLA pi_volt_Udc;

#pragma DATA_SECTION(pi_volt_Usd,"CLADataLS0");
volatile PI_NORMAL_CLA pi_volt_Usd;

#pragma DATA_SECTION(pi_volt_Usq,"CLADataLS0");
volatile PI_NORMAL_CLA pi_volt_Usq;

//#pragma DATA_SECTION(pi_volt_Usq,"CLADataLS0");
//volatile PI_NORMAL_CLA pi_volt_Usz;
//========================================================

//#pragma DATA_SECTION(Svm3d,"CLADataLS0");
//volatile SVM3D_DQZ_GEN_CLA Svm3d;

#pragma DATA_SECTION(Svm3d,"CLADataLS0");
volatile SVM3D_DQZ_GEN_CLA_1 Svm3d;

//#pragma DATA_SECTION(Svm3d,"CLADataLS0");
//volatile SVM3D_DQZ_GEN_CLA_2 Svm3d;

#pragma DATA_SECTION(Svm2d,"CLADataLS0");
volatile SVGENDQ_CLA Svm2d;

//#pragma DATA_SECTION(Rspwm,"CLADataLS0");
//volatile RSPWM_GEN_CLA Rspwm;

#pragma DATA_SECTION(pwm,"CLADataLS0");
volatile PWMGEN_3T_CLA pwm;

//======================================================
//
#pragma DATA_SECTION(UabtoUabc,"CLADataLS0");
volatile UABtoUabc_CLA UabtoUabc;

//======================================================

#pragma DATA_SECTION(rc_Ref,"CLADataLS0");
volatile RC_CLA rc_Ref;

#pragma DATA_SECTION(rc_Compen,"CLADataLS0");
volatile RC_CLA rc_Compen;

//======================================================================

//#pragma DATA_SECTION(Calculator_Rms,"CLADataLS0");
//volatile CALCULATOR_RMS_PV_CLA Calculator_Rms;

#pragma DATA_SECTION(Calculator_Ia_Rms,"CLADataLS0");
volatile CALCULATOR_RMS_CLA Calculator_Ia_Rms;
//===========================================================
#pragma DATA_SECTION(AdcValue,"CLADataLS0");
volatile ADC_VALUE AdcValue;

#pragma DATA_SECTION(adc_filter,"CLADataLS0");
volatile ADC_VALUE adc_filter;
//
/* Low pass filter  */
#pragma DATA_SECTION(filter_Udc,"CLADataLS0");
volatile LOWPASSFILTER  filter_Udc;
//
#pragma DATA_SECTION(filter_VaG,"CLADataLS0");
volatile LOWPASSFILTER  filter_VaG;
//
#pragma DATA_SECTION(filter_VbG,"CLADataLS0");
volatile LOWPASSFILTER  filter_VbG;
//
#pragma DATA_SECTION(filter_VcG,"CLADataLS0");
volatile LOWPASSFILTER  filter_VcG;

#pragma DATA_SECTION(filter_Usd,"CLADataLS0");
volatile LOWPASSFILTER  filter_Usd;

#pragma DATA_SECTION(filter_Usq,"CLADataLS0");
volatile LOWPASSFILTER  filter_Usq;

//==============================================

//#pragma DATA_SECTION(loop_volt_Us,"CLADataLS0");
//volatile short loop_volt_Us;

#pragma DATA_SECTION(loop_volt_Udc,"CLADataLS0");
volatile short loop_volt_Udc;

#pragma DATA_SECTION(count_start_CL,"CLADataLS0");
volatile short count_start_CL;

#pragma DATA_SECTION(ramp_switch,"CLADataLS0");
volatile short ramp_switch;

#pragma DATA_SECTION(switch_bdk,"CLADataLS0");
volatile short switch_bdk;

#pragma DATA_SECTION(controller_error_curr_isd,"CLADataLS0");
volatile short controller_error_curr_isd;

#pragma DATA_SECTION(controller_error_curr_isq,"CLADataLS0");
volatile short controller_error_curr_isq;

#pragma DATA_SECTION(controller_error_volt,"CLADataLS0");
volatile short controller_error_volt;

#pragma DATA_SECTION(controller_error_volt_Usd,"CLADataLS0");
volatile short controller_error_volt_Usd;

#pragma DATA_SECTION(controller_error_volt_Usq,"CLADataLS0");
volatile short controller_error_volt_Usq;

#pragma DATA_SECTION(OffsetCalCounter,"CLADataLS0");
volatile short OffsetCalCounter;

#pragma DATA_SECTION(START_CONTROLLER,"CLADataLS0");
volatile short START_CONTROLLER;

#pragma DATA_SECTION(START_ADC,"CLADataLS0");
volatile short START_ADC;

#pragma DATA_SECTION(ControlMode,"CLADataLS0");
volatile short ControlMode;

/***************************************************************************/
// The C28x instructs the CLA to change the speed or close speed loop
// These variables are declared in the message RAM

#pragma DATA_SECTION(CpuToCLA,"CpuToCla1MsgRAM");
volatile CPU_TO_CLA CpuToCLA;

#pragma DATA_SECTION(ClaToCPU,"Cla1ToCpuMsgRAM");
volatile  CLA_TO_CPU ClaToCPU;

// Whether MDEBUGSTOP needs to be compiled or not
#define CLA_DEBUG 0

float Ki_curr_test;
float Set_point_rms;
float Set_point_curr;
float Kp_curr_test;
float Ki_volt_Us_test;
float Kp_volt_Us_test;
int test;
uint16_t count;

#pragma DATA_SECTION(loop_volt_Us,"CLADataLS0");
volatile int loop_volt_Us;

interrupt void Cla1Task1 (void)
{
    #if (CLA_DEBUG == 1)
    __mdebugstop();
    #endif

    count++;
    ControlMode = CpuToCLA.ControlMode;

    if (CpuToCLA.EnableADC == 0) START_ADC = 2;
    if (CpuToCLA.EnableADC == 1 && START_ADC == 2) START_ADC = 1;
    if (START_ADC == 0)
    {
        //=========================================================================
        //   OFFSET ADC
        //========================================================================

            //=============== Hieu chinh ============/
//              adc_offset.Udc = CpuToCLA.ADCoffset_Udc;
//              adc_offset.Va_G  = CpuToCLA.ADCoffset_VaG;
//              adc_offset.Vb_G  = CpuToCLA.ADCoffset_VbG;
//              adc_offset.Vc_G  = CpuToCLA.ADCoffset_VcG;
//              adc_offset.Ia_inv = CpuToCLA.ADCoffset_Ia_inv;
//              adc_offset.Ib_inv = CpuToCLA.ADCoffset_Ib_inv;
//              adc_offset.Ic_inv = CpuToCLA.ADCoffset_Ic_inv;
            START_ADC = 1;
       }

    if(START_ADC == 1)
    {
        //=========================================================================
        //   Read ADC
        // ========================================================================

//       AdcValue.Udc     = (UDC_HCPL - adc_offset.Udc)*ADC_PU_SCALE_FACTOR_12BIT - 5.0/Udc_max;

//        if (CpuToCLA.ADCoffset_VaG > 2048.0)
//        {
//            AdcValue.Va_G = CpuToCLA.ADCgain_VaG*(VaG_HCPL - CpuToCLA.ADCoffset_VaG)/(4096.0 - CpuToCLA.ADCoffset_VaG);
//        }
//        else
//        {
//            AdcValue.Va_G = CpuToCLA.ADCgain_VaG*(VaG_HCPL - CpuToCLA.ADCoffset_VaG)/(CpuToCLA.ADCoffset_VaG);
//        }
//        if (CpuToCLA.ADCoffset_VbG > 2048.0)
//        {
//            AdcValue.Vb_G = CpuToCLA.ADCgain_VbG*(VbG_HCPL - CpuToCLA.ADCoffset_VbG)/(4096.0 - CpuToCLA.ADCoffset_VbG);
//        }
//        else
//        {
//            AdcValue.Vb_G = CpuToCLA.ADCgain_VbG*(VbG_HCPL - CpuToCLA.ADCoffset_VbG)/(CpuToCLA.ADCoffset_VbG);
//        }
//        if (CpuToCLA.ADCoffset_VcG > 2048.0)
//        {
//            AdcValue.Vc_G = CpuToCLA.ADCgain_VcG*(VcG_HCPL - CpuToCLA.ADCoffset_VcG)/(4096.0 - CpuToCLA.ADCoffset_VcG);
//        }
//        else
//        {
//            AdcValue.Vc_G = CpuToCLA.ADCgain_VcG*(VcG_HCPL - CpuToCLA.ADCoffset_VcG)/(CpuToCLA.ADCoffset_VcG);
//        }
//        if (CpuToCLA.ADCoffset_Ia_inv > 2048.0)
//        {
//            AdcValue.Ia_inv = CpuToCLA.ADCgain_Ia_inv*(IA_INV_LEM - CpuToCLA.ADCoffset_Ia_inv)/(4096.0 - CpuToCLA.ADCoffset_Ia_inv);
//        }
//        else
//        {
//            AdcValue.Ia_inv = CpuToCLA.ADCgain_Ia_inv*(IA_INV_LEM - CpuToCLA.ADCoffset_Ia_inv)/(CpuToCLA.ADCoffset_Ia_inv);
//        }
//        if (CpuToCLA.ADCoffset_Ib_inv > 2048.0)
//        {
//            AdcValue.Ib_inv = CpuToCLA.ADCgain_Ib_inv*(IB_INV_LEM  - CpuToCLA.ADCoffset_Ib_inv)/(4096.0 - CpuToCLA.ADCoffset_Ib_inv);
//        }
//        else
//        {
//            AdcValue.Ib_inv = CpuToCLA.ADCgain_Ib_inv*(IB_INV_LEM  - CpuToCLA.ADCoffset_Ib_inv)/(CpuToCLA.ADCoffset_Ib_inv);
//        }
//        if (CpuToCLA.ADCoffset_Ic_inv > 2048.0)
//        {
//            AdcValue.Ic_inv = CpuToCLA.ADCgain_Ic_inv*(IC_INV_LEM - CpuToCLA.ADCoffset_Ic_inv)/(4096.0 - CpuToCLA.ADCoffset_Ic_inv);
//        }
//        else
//        {
//            AdcValue.Ic_inv = CpuToCLA.ADCgain_Ic_inv*(IC_INV_LEM - CpuToCLA.ADCoffset_Ic_inv)/(CpuToCLA.ADCoffset_Ic_inv);
//        }
//        if (UDC_HCPL > CpuToCLA.ADCoffset_Udc)
//        {
//            AdcValue.Udc = CpuToCLA.ADCgain_Udc*(UDC_HCPL - CpuToCLA.ADCoffset_Udc)/(4096.0 - CpuToCLA.ADCoffset_Udc);
//        }
//        else AdcValue.Udc = 0.0;

        AdcValue.Va_G = 0.94*(VaG_HCPL - 2140)/(4096.0 - 2140);
        AdcValue.Vb_G = 0.9*(VbG_HCPL - 2095)/(4096.0 - 2095);
        AdcValue.Vc_G = 0.9*(VcG_HCPL - 2092)/(4096.0 - 2092);
        AdcValue.Ia_inv = 1.05*(IA_INV_LEM - 2093)/(4096.0 - 2093);
        AdcValue.Ib_inv = 1.09*(IB_INV_LEM  - 2105)/(4096.0 - 2105);
        AdcValue.Ic_inv = 0.92*(IC_INV_LEM - 2063)/(4096.0 - 2063);
        if (UDC_HCPL > 21)
        {
            AdcValue.Udc = 0.97*(UDC_HCPL - 21)/(4096.0 - 21);
        }
        else AdcValue.Udc = 0.0;

        //=========================================================================
        //  Filter signals ADC
        // ========================================================================
        filter_Udc.Vin = AdcValue.Udc;
        LOWPASSFILTER_MACRO(filter_Udc)
        adc_filter.Udc = filter_Udc.Vout;

//        --------------------------------------------
        filter_VaG.Vin = AdcValue.Va_G;
        LOWPASSFILTER_MACRO(filter_VaG);
        adc_filter.Va_G = filter_VaG.Vout;

        filter_VbG.Vin = AdcValue.Vb_G;
        LOWPASSFILTER_MACRO(filter_VbG);
        adc_filter.Vb_G = filter_VbG.Vout;

        filter_VcG.Vin = AdcValue.Vc_G;
        LOWPASSFILTER_MACRO(filter_VcG);
        adc_filter.Vc_G = filter_VcG.Vout;

        //=========================================================================================
        // Calculator Vrms, Irms of inverter
        //=========================================================================================
//        Calculator_Rms.VaG = adc_filter.Va_G;
//        Calculator_Rms.VbG = adc_filter.Vb_G;
//        Calculator_Rms.VcG = adc_filter.Vc_G;
//
//        Calculator_Rms.IaInv = AdcValue.Ia_inv;
//        Calculator_Rms.IbInv = AdcValue.Ib_inv;
//        Calculator_Rms.IcInv = AdcValue.Ic_inv;
//
//        CALCULATOR_RMS_PV_CLA_V2_MARCO(Calculator_Rms)

        //=========================================================================================
        // CLA to CPU
        //=========================================================================================

        ClaToCPU.ADC_CPU.datalog1  = AdcValue.Va_G;
        ClaToCPU.ADC_CPU.datalog2  = AdcValue.Ia_inv;
        ClaToCPU.ADC_CPU.datalog3  = pwm.MfuncA1;
//        ClaToCPU.ADC_CPU.datalog2  = pwm.MfuncA1;



//        ClaToCPU.ADC_CPU.datalog1  = park_volt_pll.alpha;
//        ClaToCPU.ADC_CPU.datalog2  = pll_3phase.Theta_har_1st;

        //=========================================================================================
        // Calculator PLL Three Phase
        //=========================================================================================

//        if(ClaToCPU.MEASUARE_CPU.VaGRms > 1.0*PV_VGRID_MIN/Us_max)
//        {
//             Calculator PLL three phase
//            clarke_volt_pll.As  = AdcValue.Va_G;
//            clarke_volt_pll.Bs  = AdcValue.Vb_G;
//            clarke_volt_pll.Cs  = AdcValue.Vc_G;
//
//            CLARKE_3PHASE_CLA_V2_MARCO(clarke_volt_pll)
//
//            park_volt_pll.alpha = clarke_volt_pll.Alpha;
//            park_volt_pll.beta = clarke_volt_pll.Beta;
//            park_volt_pll.theta = pll_3phase.Theta_har_1st;
//            park_volt_pll.sine = CLAsinPU(pll_3phase.Theta_har_1st);
//            park_volt_pll.cos = CLAcosPU(pll_3phase.Theta_har_1st);
//            PARK_CLA_V2_MACRO(park_volt_pll)
//
//            filter_Usd.Vin = park_volt_pll.d;
//            LOWPASSFILTER_MACRO(filter_Usd)
//
//            filter_Usq.Vin = park_volt_pll.q;
//            LOWPASSFILTER_MACRO(filter_Usq)
//
//            pll_3phase.Usq = filter_Usq.Vout;
//
//            PLL_PHASE_CLA_V3_MACRO(pll_3phase)

//        }
//        else
//        {
//            pll_3phase.w_I = 0;
//            pll_3phase.Theta_har_1st = 0;
//            pll_3phase.Theta_har_3rd = 0;
//        }

//        PWMDAC_MACRO((AdcValue.Ia_inv + 1.0)/2.0,(AdcValue.Ib_inv + 1.0)/2.0,(adc_filter.Va_G + 1.0)/2.0,pll_3phase.Theta_har_1st,125)

        //========================================================================
        // Level 1,2,3,4
        #if (BUILDLEVEL == LEVEL1||BUILDLEVEL == LEVEL2||BUILDLEVEL == LEVEL3)
        if(CpuToCLA.EnableFlag == 1) START_CONTROLLER = 1;
        else START_CONTROLLER = 0;
        #endif

        #if (BUILDLEVEL == LEVEL4)
        if(CpuToCLA.EnableFlag == 1)START_CONTROLLER = 1;
        else
        {
            CpuToCLA.EnableFlag = 0;
            START_CONTROLLER = 0;
        }
        #endif

        // Level 5,6
        #if (BUILDLEVEL == LEVEL5||BUILDLEVEL == LEVEL6)
        if(CpuToCLA.EnableFlag == 1)
        {
            START_CONTROLLER = 1;
        }
        else
        {
            START_CONTROLLER = 0;
        }

        #endif

        // Level All
        #if (BUILDLEVEL == LEVELALL)
        if(ControlMode == STAND_ALONE_MODE)
        {
            if(CpuToCLA.EnableFlag == 1)START_CONTROLLER = 1;
            else // CpuToCLA.EnableFlag == 0
            {
                SoftStop = 1;
                if(StopFlag == 1) START_CONTROLLER = 0;
            }
        }
        else // Grid connected
        {
            if(CpuToCLA.EnableFlag == 1)
            {
                if((adc_filter.Va_G < 0.01)&&(adc_filter.Va_G > -0.01))point_start = 1;
                if(point_start == 1 && pll_3phase.CheckPhase == 1) START_CONTROLLER = 1;
            }
            else
            {
                point_start = 0;
                START_CONTROLLER = 0;
            }
        }
        #endif

    }
    // End Adc
    //========================================================================
    if(START_CONTROLLER == 1)
    {
        if (ramp_switch == 0)
        {
            if (AdcValue.Udc <= 0.648)
            {
                EPwm1Regs.DBCTL.bit.OUT_MODE    = 2;    // Enabled Dead Band
                EPwm2Regs.DBCTL.bit.OUT_MODE    = 2;    // Enabled Dead Band
                EPwm3Regs.DBCTL.bit.OUT_MODE    = 2;    // Enabled Dead Band
                EPwm4Regs.DBCTL.bit.OUT_MODE    = 2;    // Enabled Dead Band

                Set_ramp.Udc = adc_filter.Udc;
                RAMP_GEN_CLA_V2_MACRO(Set_ramp);
                pwm.MfuncA1 = Set_ramp.Out;
                pwm.MfuncA2 = Set_ramp.Out;
                pwm.MfuncB1 = Set_ramp.Out;

//                pwm.MfuncA1 = DUTY_SET;
//                pwm.MfuncA2 = DUTY_SET;
//                pwm.MfuncB1 = DUTY_SET;

                EPwm1Regs.AQCTLA.bit.CAU = AQ_CLEAR;
                EPwm1Regs.AQCTLA.bit.CAD = AQ_SET;

                EPwm2Regs.AQCTLA.bit.CAU = AQ_CLEAR;
                EPwm2Regs.AQCTLA.bit.CAD = AQ_SET;

                EPwm3Regs.AQCTLA.bit.CAU = AQ_CLEAR;
                EPwm3Regs.AQCTLA.bit.CAD = AQ_SET;

                EPwm4Regs.AQCTLA.bit.CAU = AQ_CLEAR;
                EPwm4Regs.AQCTLA.bit.CAD = AQ_SET;
                PWM_3T_MACRO(pwm)
            }
            else ramp_switch = 1;
        }
        if (ramp_switch == 1)
        {
            EPwm1Regs.DBCTL.bit.OUT_MODE    = 3;    // Enabled Dead Band
            EPwm2Regs.DBCTL.bit.OUT_MODE    = 3;    // Enabled Dead Band
            EPwm3Regs.DBCTL.bit.OUT_MODE    = 3;    // Enabled Dead Band
            EPwm4Regs.DBCTL.bit.OUT_MODE    = 3;    // Enabled Dead Band

#if (BUILDLEVEL == LEVEL1)

        IsrTicker++;

        // ------------------------------------------------------------------------------
        //  Ramp reference voltage
        // ------------------------------------------------------------------------------

        rg_har_1st.Freq = CpuToCLA.Fref;
        RAMP_GEN_CLA_MACRO(rg_har_1st)

        rc_Ref.TargetValue = CpuToCLA.VdTesting; // 220/400
        RC_CLA_MACRO(rc_Ref)

        // ------------------------------------------------------------------------------
        //  IPARK
        // ------------------------------------------------------------------------------

        ipark_voltref.d    = can2*rc_Ref.SetpointValue;
        ipark_voltref.q    = CpuToCLA.VqTesting;  // 0
        ipark_voltref.z    = CpuToCLA.VzTesting;  // 0
        ipark_voltref.sine = CLAsinPU(rg_har_1st.Out);
        ipark_voltref.cos  = CLAcosPU(rg_har_1st.Out);
        iPARK_CLA_V3_MACRO(ipark_voltref)       // dqz sang alpha-beta-gamma

        // ------------------------------------------------------------------------------
        //  ICLARKE
        // ------------------------------------------------------------------------------

        UabtoUabc.Ualpha = ipark_voltref.alpha;
        UabtoUabc.Ubeta = ipark_voltref.beta;
        UabtoUabc.Ugamma = ipark_voltref.gamma;
        UABtoUabc_CLA_V2_MACRO(UabtoUabc)  //alpha-beta-gamma sang abc

        //----------------------------------------------------------------------------
        //  SVM-3D
        //----------------------------------------------------------------------------
        Svm3d.Ualpha = ipark_voltref.alpha;
        Svm3d.Ubeta = ipark_voltref.beta;
        Svm3d.Ugamma = ipark_voltref.gamma;
        Svm3d.Udc = CpuToCLA.UdcTesting;    //650/800
//        Svm3d.Udc = adc_filter.Udc;
//        Svm3d.Udc = 100.0/Udc_max;
        SVM3D_DQZ_GEN_CLA_MACRO_1(Svm3d)

        // ------------------------------------------------------------------------------
        //  Connect inputs of the PWM_DRV module and call the PWM signal generation macro
        // ------------------------------------------------------------------------------
        pwm.MfuncA1 = Svm3d.da;
        pwm.MfuncA2 = Svm3d.db;
        pwm.MfuncB1 = Svm3d.dc;
        pwm.MfuncB2 = Svm3d.dn;

        //----------------------------------------------------------------------------
        //  RSPWM
        //----------------------------------------------------------------------------
//        Rspwm.Ualpha = ipark_voltref.alpha;
//        Rspwm.Ubeta = ipark_voltref.beta;
//        Rspwm.Ugamma = ipark_voltref.gamma;
//        Rspwm.Udc = CpuToCLA.UdcTesting;
//        RSPWM_GEN_CLA_MACRO(Rspwm)

        // ------------------------------------------------------------------------------
        //  Connect inputs of the PWM_DRV module and call the PWM signal generation macro
        // ------------------------------------------------------------------------------
//        pwm.MfuncA1 = Rspwm.da;
//        pwm.MfuncA2 = Rspwm.db;
//        pwm.MfuncB1 = Rspwm.dc;

        PWM_3T_MACRO(pwm)

        // ------------------------------------------------------------------------------
        //  CLA to CPU
        // ------------------------------------------------------------------------------
//        ClaToCPU.MEASUARE_CPU.da   = Svm3d.da;
//        ClaToCPU.ADC_CPU.Theta     = rg_har_1st.Out;
//        ClaToCPU.MEASUARE_CPU.Ua   = UabtoUabc.Ua;
//        ClaToCPU.MEASUARE_CPU.Prism = Svm3d.Prism;
//        ClaToCPU.ADC_CPU.Va_G = adc_filter.Va_G;

        // ------------------------------------------------------------------------------
        //  Connect inputs of the PWMDAC module
        // ------------------------------------------------------------------------------
        //PWMDAC_MACRO(Svm3d.da,(adc_filter.Va_G + 1.0)/2.0,(UabtoUabc.Ua + 1.0)/2.0,((float)(adc_filter.Va_G) + 1.0)/2.0,125)
        PWMDAC_MACRO(Svm3d.da,Svm3d.db,Svm3d.dc,Svm3d.dn,125)

    #endif

#if (BUILDLEVEL == LEVEL2)                                  // open loop with 3-rd

        IsrTicker++;
        //----------------------------------------------------------------------------

        rg_har_1st.Freq = CpuToCLA.Fref;                    //
        RAMP_GEN_CLA_MACRO(rg_har_1st)

        rg_har_3rd.Freq = 3.0*CpuToCLA.Fref;
        RAMP_GEN_CLA_MACRO(rg_har_3rd)

        rc_Ref.TargetValue = CpuToCLA.VdTesting;
        RC_CLA_MACRO(rc_Ref)

       // ------------------------------------------------------------------------------
       //   IPARK
       // ------------------------------------------------------------------------------

        ipark_voltref.d    = can2*rc_Ref.SetpointValue;
        ipark_voltref.q    = CpuToCLA.VqTesting;
        ipark_voltref.sine = CLAsinPU(rg_har_1st.Out);
        ipark_voltref.cos  = CLAcosPU(rg_har_1st.Out);
        iPARK_CLA_MACRO(ipark_voltref)

        // ------------------------------------------------------------------------------
        //   Uapha, Ubeta ---> Ua, Ub, Uc
        // ------------------------------------------------------------------------------

        UabtoUabc.Ualpha = ipark_voltref.alpha;
        UabtoUabc.Ubeta = ipark_voltref.beta;
        UABtoUabc_CLA_MACRO(UabtoUabc);

        //----------------------------------------------------------------------------
        //   Harmonic 3rd
        //----------------------------------------------------------------------------

//        Us_har_3rd = 0.2*can2*rc_Ref.SetpointValue*CLAcosPU(rg_har_3rd.Out + 0.5);
        Us_har_3rd = 0.16*can2*rc_Ref.SetpointValue*CLAcosPU(rg_har_3rd.Out + 0.5);
        //----------------------------------------------------------------------------
        //   SinPWM
        //----------------------------------------------------------------------------

        Sinpwm.Ua   = UabtoUabc.Ua + Us_har_3rd;
        Sinpwm.Ub   = UabtoUabc.Ub + Us_har_3rd;
        Sinpwm.Uc   = UabtoUabc.Uc + Us_har_3rd;
        Sinpwm.Udc   = CpuToCLA.UdcTesting;
        SPWM_T_TYPE_CLA_MARCO(Sinpwm);
        ClaToCPU.ADC_CPU.sinApwm   = Sinpwm.Ua;
        // ------------------------------------------------------------------------------
        //  Connect inputs of the PWM_DRV module and call the PWM signal generation macro
        // ------------------------------------------------------------------------------

        pwm.MfuncA1 = Sinpwm.Ta1;
        pwm.MfuncA2 = Sinpwm.Ta2;

        pwm.MfuncB1 = Sinpwm.Tb1;
        pwm.MfuncB2 = Sinpwm.Tb2;

        pwm.MfuncC1 = Sinpwm.Tc1;
        pwm.MfuncC2 = Sinpwm.Tc2;

        pwm.MfuncA1 = 500;
        pwm.MfuncA2 = 500;
        PWM_3T_MACRO(pwm);

        // ------------------------------------------------------------------------------
        //    Connect inputs of the PWMDAC module
        // ------------------------------------------------------------------------------

        PWMDAC_MACRO((Sinpwm.Ta1 + 1.0)/2.0,(UabtoUabc.Ua + 1.0)/2.0,(Us_har_3rd + 1.0)/2.0,(rg_har_1st.Out + 1.0)/2.0,125)

    #endif

#if (BUILDLEVEL == LEVEL3)

        IsrTicker++;

        //----------------------------------------------------------------------------

        rg_har_1st.Freq = 50.00/150.0;
        RAMP_GEN_CLA_MACRO(rg_har_1st) //tao theta

//        rc_Ref.TargetValue = CpuToCLA.IdRef;
        rc_Ref.TargetValue = 1.5/81.3; //Id*
        RC_CLA_MACRO(rc_Ref) //ramp luong dat Id

        // ------------------------------------------------------------------------------
        //  Measure phase currents, subtract the offset and normalize from (-0.5,+0.5) to (-1,+1).
        //  Connect inputs of the CLARKE module and call the clarke transformation macro
        // ------------------------------------------------------------------------------
        clarke_curr.As  = AdcValue.Ia_inv;  // Phase A curr.
        clarke_curr.Bs  = AdcValue.Ib_inv;  // Phase B curr.
        clarke_curr.Cs  = AdcValue.Ic_inv;
        CLARKE_3PHASE_CLA_V3_MARCO(clarke_curr) //chuyen abc sang anpha-beta-gamma

        // ------------------------------------------------------------------------------
        //  Connect inputs of the PARK module and call the park trans. macro
        // ------------------------------------------------------------------------------
        park_curr.theta = rg_har_1st.Out; //dau ra cua rg_har_1st chinh la theta
        park_curr.alpha = clarke_curr.Alpha;
        park_curr.beta = clarke_curr.Beta;
        park_curr.gamma = clarke_curr.Gamma;
        park_curr.sine  = CLAsinPU(rg_har_1st.Out); //sin(theta)
        park_curr.cos  = CLAcosPU(rg_har_1st.Out); //cos(theta)
        PARK_CLA_V3_MACRO(park_curr) //chuyen anpha-beta-gamma sang dqz

        //==============================================================================
        // Current controller

        pi_curr_id.REF      = can2*rc_Ref.SetpointValue; //SetpointValue la gia tri dat sau ramp
        pi_curr_id.INPUT    = park_curr.d;  //Id dau vao la gia tri d sau khoi park
        pi_curr_id.ERROR    = pi_curr_id.REF - pi_curr_id.INPUT; //do sai lech
        PI_NORMAL_MACRO(pi_curr_id);

        pi_curr_iq.REF      = CpuToCLA.IqRef; //CpuToCLA.IqRef = 0
        pi_curr_iq.INPUT    = park_curr.q; //Iq dau vao la gia tri q sau khoi park
        pi_curr_iq.ERROR    = pi_curr_iq.REF - pi_curr_iq.INPUT; //do sai lech
        PI_NORMAL_MACRO(pi_curr_iq);

        pi_curr_iz.REF      = CpuToCLA.IzRef; //
        pi_curr_iz.INPUT    = park_curr.z; //Iz dau vao la gia tri z sau khoi park
        pi_curr_iz.ERROR    = pi_curr_iz.REF - pi_curr_iz.INPUT; //do sai lech
        PI_NORMAL_MACRO(pi_curr_iz);

        // ------------------------------------------------------------------------------
        //  Connect inputs of the INV_PARK module and call the inverse park trans. macro
        // ------------------------------------------------------------------------------

        ipark_voltref.d = pi_curr_id.OUT;
        ipark_voltref.q = pi_curr_iq.OUT;
        ipark_voltref.z = pi_curr_iz.OUT;
        ipark_voltref.sine = CLAsinPU(rg_har_1st.Out); //sin(theta)
        ipark_voltref.cos  = CLAcosPU(rg_har_1st.Out); //cos(theta)
        iPARK_CLA_V3_MACRO(ipark_voltref) //chuyen dqz sang anpha-beta-gamma

        //----------------------------------------------------------------------------
        //  SVM-3D
        //----------------------------------------------------------------------------
        Svm3d.Ualpha = ipark_voltref.alpha;
        Svm3d.Ubeta = ipark_voltref.beta;
        Svm3d.Ugamma = ipark_voltref.gamma;
        Svm3d.Udc = AdcValue.Udc;

        SVM3D_DQZ_GEN_CLA_MACRO_1(Svm3d)

//        // ------------------------------------------------------------------------------
//        //  Connect inputs of the PWM_DRV module and call the PWM signal generation macro
//        // ------------------------------------------------------------------------------
        pwm.MfuncA1 = Svm3d.da;
        pwm.MfuncA2 = Svm3d.db;
        pwm.MfuncB1 = Svm3d.dc;
        pwm.MfuncB2 = Svm3d.dn;

        PWM_3T_MACRO(pwm);
//
        // ------------------------------------------------------------------------------
        //    Connect inputs of the PWMDAC module
        // ------------------------------------------------------------------------------
        PWMDAC_MACRO((pi_curr_id.REF + 1.0)/2.0,(park_curr.d + 1.0)/2.0,(CpuToCLA.IqRef + 1.0)/2.0,(park_curr.q + 1.0)/2.0,125)

        if(pi_curr_id.OUT > 0.99 || pi_curr_id.OUT < -0.99)controller_error_curr_isd++;
        else controller_error_curr_isd = 0;

        if(pi_curr_id.OUT > 0.99 || pi_curr_id.OUT < -0.99) controller_error_curr_isq++;
        else controller_error_curr_isq = 0;

    #endif

#if (BUILDLEVEL == LEVEL4)

         IsrTicker++;
         //----------------------------------------------------------------------------
         rg_har_1st.Freq = 50.00/150.0;
         RAMP_GEN_CLA_MACRO(rg_har_1st) //Tao theta

         rc_Compen.TargetValue = 0.8;
         RC_CLA_MACRO(rc_Compen)

         // RAMP Ud Ref
         rc_Ref.TargetValue = can2*CpuToCLA.VdTesting; //Dat gia tri Ud*
//         Set_point_rms = 30.0;
//         rc_Ref.TargetValue = can2*Set_point_rms/400.0;
         RC_CLA_MACRO(rc_Ref) //ramp gia tri Ud*

         // ------------------------------------------------------------------------------
         //  Connect inputs of the CLARKE module and call the clarke transformation macro
         // ------------------------------------------------------------------------------

         clarke_curr.As  = AdcValue.Ia_inv;  // Phase A curr.
         clarke_curr.Bs  = AdcValue.Ib_inv;  // Phase B curr.
         clarke_curr.Cs  = AdcValue.Ic_inv;
         CLARKE_3PHASE_CLA_V3_MARCO(clarke_curr)

         // ------------------------------------------------------------------------------
         //  Connect inputs of the CLARKE module and call the clarke transformation macro
         // ------------------------------------------------------------------------------

         clarke_volt.As  = AdcValue.Va_G;  // Phase A volt
         clarke_volt.Bs  = AdcValue.Vb_G;  // Phase B volt.
         clarke_volt.Cs  = AdcValue.Vc_G;
//         clarke_volt.As  = adc_filter.Va_G;  // Phase A volt
//         clarke_volt.Bs  = adc_filter.Vb_G;  // Phase B volt.
//         clarke_volt.Cs  = adc_filter.Vc_G;
         CLARKE_3PHASE_CLA_V3_MARCO(clarke_volt)

         // ------------------------------------------------------------------------------
         //  Connect inputs of the PARK module and call the park trans. macro
         // ------------------------------------------------------------------------------
         park_curr.theta = rg_har_1st.Out;
         park_curr.alpha = clarke_curr.Alpha;
         park_curr.beta  = clarke_curr.Beta;
         park_curr.gamma = clarke_curr.Gamma;
         park_curr.sine  = CLAsinPU(rg_har_1st.Out);
         park_curr.cos   = CLAcosPU(rg_har_1st.Out);

         PARK_CLA_V3_MACRO(park_curr)

         // ------------------------------------------------------------------------------
         //  Connect inputs of the PARK module and call the park trans. macro
         // ------------------------------------------------------------------------------
         park_volt.theta = rg_har_1st.Out;
         park_volt.alpha = clarke_volt.Alpha;
         park_volt.beta  = clarke_volt.Beta;
         park_volt.gamma = clarke_volt.Gamma;
         park_volt.sine  = CLAsinPU(rg_har_1st.Out);
         park_volt.cos   = CLAcosPU(rg_har_1st.Out);
         PARK_CLA_V3_MACRO(park_volt)

         //--------------------------------------------------------
         // Voltage controller

         if(loop_volt_Us >= 10)
         {
             pi_volt_Usd.REF      = rc_Ref.SetpointValue;
             pi_volt_Usd.INPUT    = park_volt.d;
             pi_volt_Usd.ERROR    = pi_volt_Usd.REF - pi_volt_Usd.INPUT;
             PI_NORMAL_MACRO(pi_volt_Usd)

             pi_volt_Usq.REF      = 0.0;
             pi_volt_Usq.INPUT    = park_volt.q;
             pi_volt_Usq.ERROR    = pi_volt_Usq.REF - pi_volt_Usq.INPUT;
             PI_NORMAL_MACRO(pi_volt_Usq)

             loop_volt_Us = 1;
         }
         else loop_volt_Us++;

         //==============================================================================
         //Thay doi bo dieu khien khi switch_bdk = 1
         #if(SWITCH_BDK_MODE == ALLOW_SWITCH_BDK)
             if(switch_bdk == 1)
             {
                 pi_curr_id.Kp = KP_CURR_LOOP;
                 pi_curr_id.Ki = KI_CURR_LOOP;

                 pi_curr_iq.Kp = KP_CURR_LOOP;
                 pi_curr_iq.Ki = KI_CURR_LOOP;

                 pi_curr_iz.Kp = KP_CURR_LOOP;
                 pi_curr_iz.Ki = KI_CURR_LOOP;
             }
             else if(switch_bdk == 0)
             {
                 pi_curr_id.Kp = KP_CURR_LOOP_1;
                 pi_curr_id.Ki = KI_CURR_LOOP_1;

                 pi_curr_iq.Kp = KP_CURR_LOOP_1;
                 pi_curr_iq.Ki = KI_CURR_LOOP_1;

                 pi_curr_iz.Kp = KP_CURR_LOOP_1;
                 pi_curr_iz.Ki = KI_CURR_LOOP_1;
             }

         #endif
         // Current controller

         pi_curr_id.REF      = pi_volt_Usd.OUT;
         pi_curr_id.INPUT    = park_curr.d;
         pi_curr_id.ERROR    =  pi_curr_id.REF - pi_curr_id.INPUT ;
         PI_NORMAL_MACRO(pi_curr_id);

         pi_curr_iq.REF      = pi_volt_Usq.OUT;
         pi_curr_iq.INPUT    = park_curr.q;
         pi_curr_iq.ERROR    =  pi_curr_iq.REF - pi_curr_iq.INPUT;
         PI_NORMAL_MACRO(pi_curr_iq);

         pi_curr_iz.REF      = 0.0;
         pi_curr_iz.INPUT    = park_curr.z;
         pi_curr_iz.ERROR    =  pi_curr_iz.REF - pi_curr_iz.INPUT ;
         PI_NORMAL_MACRO(pi_curr_iz);

         // ------------------------------------------------------------------------------
         //  Connect inputs of the INV_PARK module and call the inverse park trans. macro
         // ------------------------------------------------------------------------------

         ipark_voltref.d = pi_curr_id.OUT;
         ipark_voltref.q = pi_curr_iq.OUT;
//         ipark_voltref.d = pi_curr_id.OUT - rc_Compen.SetpointValue*filter_Usd.Vin;
//         ipark_voltref.q = pi_curr_iq.OUT - rc_Compen.SetpointValue*filter_Usq.Vin;
         ipark_voltref.z = pi_curr_iz.OUT;

         ipark_voltref.sine = CLAsinPU(rg_har_1st.Out);
         ipark_voltref.cos  = CLAcosPU(rg_har_1st.Out);
         iPARK_CLA_V3_MACRO(ipark_voltref)
         //----------------------------------------------------------------------------
         //  SVM-3D
         //----------------------------------------------------------------------------
         Svm3d.Ualpha = ipark_voltref.alpha;
         Svm3d.Ubeta  = ipark_voltref.beta;
         Svm3d.Ugamma = ipark_voltref.gamma;
         Svm3d.Udc = adc_filter.Udc;
//         Svm3d.Udc = AdcValue.Udc;
         SVM3D_DQZ_GEN_CLA_MACRO_1(Svm3d)

          // ------------------------------------------------------------------------------
          //  Connect inputs of the PWM_DRV module and call the PWM signal generation macro
          // ------------------------------------------------------------------------------
         pwm.MfuncA1 = Svm3d.da;
         pwm.MfuncA2 = Svm3d.db;
         pwm.MfuncB1 = Svm3d.dc;
         pwm.MfuncB2 = Svm3d.dn;

         //SVM-2D
//         Svm2d.Ualpha = ipark_voltref.alpha;
//         Svm2d.Ubeta = ipark_voltref.beta;
//         Svm2d.Udc = AdcValue.Udc;
//         SVGEN_CLA_MACRO(Svm2d)
//
//         pwm.MfuncA1 = Svm2d.da;
//         pwm.MfuncA2 = Svm2d.db;
//         pwm.MfuncB1 = Svm2d.dc;
//         pwm.MfuncB2 = Svm2d.dn;
//
         PWM_3T_MACRO(pwm);

    #endif

#if (BUILDLEVEL == LEVEL5)

          IsrTicker++;

          // ------------------------------------------------------------------------------
          //  Ramp reference current
          // ------------------------------------------------------------------------------
          rc_Ref.TargetValue = can2*2.0/81.3;
          RC_CLA_MACRO(rc_Ref)

          // ------------------------------------------------------------------------------
          //  Connect inputs of the CLARKE module and call the clarke transformation macro
          // ------------------------------------------------------------------------------
          clarke_curr.As  = AdcValue.Ia_inv;  // Phase A curr.
          clarke_curr.Bs  = AdcValue.Ib_inv;  // Phase B curr.
          clarke_curr.Cs  = AdcValue.Ic_inv;  // Phase C curr

          CLARKE_3PHASE_CLA_V3_MARCO(clarke_curr)

          // ------------------------------------------------------------------------------
          //  Connect inputs of the PARK module and call the park trans. macro
          // ------------------------------------------------------------------------------
          park_curr.theta = pll_3phase.Theta_har_1st;
          park_curr.alpha = clarke_curr.Alpha;
          park_curr.beta = clarke_curr.Beta;
          park_curr.gamma = clarke_curr.Gamma;
          park_curr.sine  = CLAsinPU(pll_3phase.Theta_har_1st);
          park_curr.cos  = CLAcosPU(pll_3phase.Theta_har_1st);
          PARK_CLA_V3_MACRO(park_curr)

          //==============================================================================
          //  Current controller
          // ------------------------------------------------------------------------------
          pi_curr_id.REF      = rc_Ref.SetpointValue;
          pi_curr_id.INPUT    = park_curr.d;
          pi_curr_id.ERROR    = pi_curr_id.REF - pi_curr_id.INPUT;
          PI_NORMAL_MACRO(pi_curr_id);

          pi_curr_iq.REF      = CpuToCLA.IqRef;
          pi_curr_iq.INPUT    = park_curr.q;
          pi_curr_iq.ERROR    = pi_curr_iq.REF - pi_curr_iq.INPUT;
          PI_NORMAL_MACRO(pi_curr_iq);

          pi_curr_iz.REF      = CpuToCLA.IzRef;
          pi_curr_iz.INPUT    = park_curr.z;
          pi_curr_iz.ERROR    = pi_curr_iz.REF - pi_curr_iz.INPUT;
          PI_NORMAL_MACRO(pi_curr_iz);

          // ------------------------------------------------------------------------------
          //  Connect inputs of the INV_PARK module and call the inverse park trans. macro
          // ------------------------------------------------------------------------------

          ipark_voltref.d = pi_curr_id.OUT  + filter_Usd.Vout;
          ipark_voltref.q = pi_curr_iq.OUT  + filter_Usq.Vout;
          ipark_voltref.z = pi_curr_iz.OUT;

//          ipark_voltref.d = pi_curr_id.OUT  + filter_Usd.Vout + Wref*Li*park_curr.q*Is_max/Us_max;
//          ipark_voltref.q = pi_curr_iq.OUT  + filter_Usq.Vout - Wref*Li*park_curr.d*Is_max/Us_max;
//          ipark_voltref.z = pi_curr_iz.OUT;

          ipark_voltref.sine = CLAsinPU(pll_3phase.Theta_har_1st);
          ipark_voltref.cos  = CLAcosPU(pll_3phase.Theta_har_1st);
          iPARK_CLA_V3_MACRO(ipark_voltref)

#if(MODULATION == SVM3D)
          //----------------------------------------------------------------------------
          //  SVM-3D
          //----------------------------------------------------------------------------
          Svm3d.Ualpha = ipark_voltref.alpha;
          Svm3d.Ubeta = ipark_voltref.beta;
          Svm3d.Ugamma = ipark_voltref.gamma;
          Svm3d.Udc = AdcValue.Udc;
          SVM3D_DQZ_GEN_CLA_MACRO_1(Svm3d)

          // ------------------------------------------------------------------------------
          //  Connect inputs of the PWM_DRV module and call the PWM signal generation macro
          // ------------------------------------------------------------------------------
          pwm.MfuncA1 = Svm3d.da;
          pwm.MfuncA2 = Svm3d.db;
          pwm.MfuncB1 = Svm3d.dc;
          pwm.MfuncB2 = Svm3d.dn;
#endif

#if(MODULATION == RSPWM)
          //----------------------------------------------------------------------------
          //  RSPWM
          //----------------------------------------------------------------------------
          Rspwm.Ualpha = ipark_voltref.alpha;
          Rspwm.Ubeta = ipark_voltref.beta;
          Rspwm.Ugamma = ipark_voltref.gamma;
          Rspwm.Udc = CpuToCLA.UdcTesting;
          RSPWM_GEN_CLA_MACRO(Rspwm)

          // ------------------------------------------------------------------------------
          //  Connect inputs of the PWM_DRV module and call the PWM signal generation macro
          // ------------------------------------------------------------------------------
          pwm.MfuncA1 = Rspwm.da;
          pwm.MfuncA2 = Rspwm.db;
          pwm.MfuncB1 = Rspwm.dc;
#endif

          PWM_3T_MACRO(pwm)

    #endif

#if (BUILDLEVEL == LEVEL6)

       IsrTicker++;

       // ------------------------------------------------------------------------------
       //  Connect inputs of the CLARKE module and call the clarke transformation macro
       // ------------------------------------------------------------------------------
       clarke_curr.As  = AdcValue.Ia_inv;  // Phase A curr
       clarke_curr.Bs  = AdcValue.Ib_inv;  // Phase B curr
       clarke_curr.Cs  = AdcValue.Ic_inv;  // Phase C curr

       CLARKE_3PHASE_CLA_V3_MARCO(clarke_curr)

       // ------------------------------------------------------------------------------
       //  Connect inputs of the PARK module and call the park trans. macro
       // ------------------------------------------------------------------------------
       park_curr.theta = pll_3phase.Theta_har_1st;
       park_curr.alpha = clarke_curr.Alpha;
       park_curr.beta = clarke_curr.Beta;
       park_curr.gamma = clarke_curr.Gamma;
       park_curr.sine  = CLAsinPU(pll_3phase.Theta_har_1st);
       park_curr.cos  = CLAcosPU(pll_3phase.Theta_har_1st);
       PARK_CLA_V3_MACRO(park_curr)

       // ------------------------------------------------------------------------------
       //  Voltage Controller
       // ------------------------------------------------------------------------------
       if(loop_volt_Udc >= 10)
       {
           if(count_start_CL == 1)
           {
               rc_Ref.SetpointValue = AdcValue.Udc;
               count_start_CL = 0;
           }
           rc_Ref.TargetValue = 80.0/800;
           RC_CLA_MACRO(rc_Ref)
           pi_volt_Udc.REF = rc_Ref.SetpointValue;
//           pi_volt_Udc.REF = CpuToCLA.UdcRef;
           pi_volt_Udc.INPUT = AdcValue.Udc;
           pi_volt_Udc.ERROR = - pi_volt_Udc.REF + pi_volt_Udc.INPUT;
           PI_NORMAL_MACRO(pi_volt_Udc)
           loop_volt_Udc = 1;
       }
       else loop_volt_Udc++;

       // ------------------------------------------------------------------------------
       //  Current Controller
       // ------------------------------------------------------------------------------
       pi_curr_id.REF      = pi_volt_Udc.OUT;
       pi_curr_id.INPUT    = park_curr.d;
       pi_curr_id.ERROR    = pi_curr_id.REF - pi_curr_id.INPUT;
       PI_NORMAL_MACRO(pi_curr_id);

       pi_curr_iq.REF      = CpuToCLA.IqRef;
       pi_curr_iq.INPUT    = park_curr.q;
       pi_curr_iq.ERROR    = pi_curr_iq.REF - pi_curr_iq.INPUT;
       PI_NORMAL_MACRO(pi_curr_iq);

       pi_curr_iz.REF      = CpuToCLA.IzRef;
       pi_curr_iz.INPUT    = park_curr.z;
       pi_curr_iz.ERROR    = pi_curr_iz.REF - pi_curr_iz.INPUT;
       PI_NORMAL_MACRO(pi_curr_iz);

       // ------------------------------------------------------------------------------
       //  Connect inputs of the INV_PARK module and call the inverse park trans. macro
       // ------------------------------------------------------------------------------
//       ipark_voltref.d = pi_curr_id.OUT;
//       ipark_voltref.q = pi_curr_iq.OUT;
//       ipark_voltref.z = pi_curr_iz.OUT;

       ipark_voltref.d = pi_curr_id.OUT  + filter_Usd.Vout;
       ipark_voltref.q = pi_curr_iq.OUT  + filter_Usq.Vout;
       ipark_voltref.z = pi_curr_iz.OUT;

//       ipark_voltref.d = pi_curr_id.OUT  + filter_Usd.Vout + Wref*Li*park_curr.q*Is_max/Us_max;
//       ipark_voltref.q = pi_curr_iq.OUT  + filter_Usq.Vout - Wref*Li*park_curr.d*Is_max/Us_max;
//       ipark_voltref.z = pi_curr_iz.OUT;

       ipark_voltref.sine = CLAsinPU(pll_3phase.Theta_har_1st);
       ipark_voltref.cos  = CLAcosPU(pll_3phase.Theta_har_1st);
       iPARK_CLA_V3_MACRO(ipark_voltref)

#if(MODULATION == SVM3D)
       //----------------------------------------------------------------------------
       //  SVM-3D
       //----------------------------------------------------------------------------
       Svm3d.Ualpha = ipark_voltref.alpha;
       Svm3d.Ubeta = ipark_voltref.beta;
       Svm3d.Ugamma = ipark_voltref.gamma;
       Svm3d.Udc = AdcValue.Udc;
       SVM3D_DQZ_GEN_CLA_MACRO_1(Svm3d)

//        ------------------------------------------------------------------------------
//         Connect inputs of the PWM_DRV module and call the PWM signal generation macro
//        ------------------------------------------------------------------------------
       pwm.MfuncA1 = Svm3d.da;
       pwm.MfuncA2 = Svm3d.db;
       pwm.MfuncB1 = Svm3d.dc;
       pwm.MfuncB2 = Svm3d.dn;
#endif

#if(MODULATION == RSPWM)
          //----------------------------------------------------------------------------
          //  RSPWM
          //----------------------------------------------------------------------------
          Rspwm.Ualpha = ipark_voltref.alpha;
          Rspwm.Ubeta = ipark_voltref.beta;
          Rspwm.Ugamma = ipark_voltref.gamma;
          Rspwm.Udc = adc_filter.Udc;
          RSPWM_GEN_CLA_MACRO(Rspwm)

          // ------------------------------------------------------------------------------
          //  Connect inputs of the PWM_DRV module and call the PWM signal generation macro
          // ------------------------------------------------------------------------------
          pwm.MfuncA1 = Rspwm.da;
          pwm.MfuncA2 = Rspwm.db;
          pwm.MfuncB1 = Rspwm.dc;
#endif
       PWM_3T_MACRO(pwm)

       // ------------------------------------------------------------------------------
       //  Connect inputs of the PWMDAC module
       // ------------------------------------------------------------------------------
//       PWMDAC_MACRO((adc_filter.Va_G + 1.0)/2.0,(AdcValue.Ia_inv + 1.0)/2.0,pll_3phase.Theta_har_1st,adc_filter.Udc,125)

    #endif

#if (BUILDLEVEL == LEVELALL)

         IsrTicker++;

         //----------------------------------------------------------------------------
         // Stand alone
         if(ControlMode == STAND_ALONE_MODE)
         {
             //----------------------------------------------------------------------------

             rg_har_1st.Freq = CpuToCLA.Fref;
             RAMP_GEN_CLA_MACRO(rg_har_1st)

             rg_har_3rd.Freq = 3.0*CpuToCLA.Fref;
             RAMP_GEN_CLA_MACRO(rg_har_3rd)

             // RAMP Ud Ref
             rc_Ref.StepRampDec = 0.01/Us_max;
             rc_Ref.StepRampInc = 0.01/Us_max;

             rc_Ref.TargetValue = CpuToCLA.UdRef;

             if(SoftStop == 1)
             {
                 rc_Ref.TargetValue = 0;
                 if(rc_Ref.SetpointValue < 2.0/Us_max) StopFlag = 1;
             }

             RC_CLA_MACRO(rc_Ref)

             // ------------------------------------------------------------------------------
             //  Connect inputs of the CLARKE module and call the clarke transformation macro
             // ------------------------------------------------------------------------------

             clarke_volt.As  = adc_filter.Va_L;  // Phase A volt
             clarke_volt.Bs  = adc_filter.Vb_L;  // Phase B volt.
             clarke_volt.Cs  = adc_filter.Vc_L;

             CLARKE_3PHASE_CLA_V2_MARCO(clarke_volt)

             // ------------------------------------------------------------------------------
             //  Connect inputs of the PARK module and call the park trans. macro
             // ------------------------------------------------------------------------------
             park_volt.theta = rg_har_1st.Out;
             park_volt.alpha = clarke_volt.Alpha;
             park_volt.beta = clarke_volt.Beta;
             park_volt.sine  = CLAsinPU(rg_har_1st.Out);
             park_volt.cos  = CLAcosPU(rg_har_1st.Out);
             PARK_CLA_MACRO(park_volt)

             //--------------------------------------------------------
             // Voltage controller

             if(loop_volt_Us >= 10)
             {

                 pi_volt_Usd.REF      = can2*rc_Ref.SetpointValue;
                 pi_volt_Usd.INPUT    = park_volt.d;
                 pi_volt_Usd.ERROR    = pi_volt_Usd.REF - pi_volt_Usd.INPUT;
                 PI_NORMAL_MACRO(pi_volt_Usd)

                 pi_volt_Usq.REF      = CpuToCLA.UqRef;
                 pi_volt_Usq.INPUT    = park_volt.q;
                 pi_volt_Usq.ERROR    = pi_volt_Usq.REF - pi_volt_Usq.INPUT;
                 PI_NORMAL_MACRO(pi_volt_Usq)

                 loop_volt_Us = 1;
             }
             else loop_volt_Us++;
         }
         else  // Grid connected
         {
             rc_Ref.StepRampDec = 0.1/Udc_max;
             rc_Ref.StepRampInc = 0.1/Udc_max;

             //=============== VOLTAGLE CONTROL  =============================================
             if(loop_volt_Udc >= 10)
             {
                 if(count_start_CL == 1)
                 {
                     rc_Ref.SetpointValue = adc_filter.Udc;
                     count_start_CL = 0;
                 }
                 rc_Ref.TargetValue = CpuToCLA.UdcRef;
                 RC_CLA_MACRO(rc_Ref)
                 pi_volt_Udc.REF = rc_Ref.SetpointValue;
                 pi_volt_Udc.INPUT = adc_filter.Udc;
                 pi_volt_Udc.ERROR = - pi_volt_Udc.REF + pi_volt_Udc.INPUT;
                 PI_NORMAL_MACRO(pi_volt_Udc)
                 loop_volt_Udc = 1;
              }
               else loop_volt_Udc++;
         }

         // ------------------------------------------------------------------------------
         // CLARKE Curr
         clarke_curr.As  = AdcValue.Ia_inv;  // Phase A curr.
         clarke_curr.Bs  = AdcValue.Ib_inv;  // Phase B curr.
         clarke_curr.Cs  = AdcValue.Ic_inv;

         CLARKE_3PHASE_CLA_V2_MARCO(clarke_curr)

         // ------------------------------------------------------------------------------
         // Park Curr
         if(ControlMode == STAND_ALONE_MODE)
         {
             park_curr.theta = rg_har_1st.Out;
             park_curr.sine  = CLAsinPU(rg_har_1st.Out);
             park_curr.cos  = CLAcosPU(rg_har_1st.Out);
         }
         else // Grid connected
         {
             park_curr.theta = pll_3phase.Theta_har_1st;
             park_curr.sine  = CLAsinPU(pll_3phase.Theta_har_1st);
             park_curr.cos  = CLAcosPU(pll_3phase.Theta_har_1st);
         }

         park_curr.alpha = clarke_curr.Alpha;
         park_curr.beta = clarke_curr.Beta;
         PARK_CLA_MACRO(park_curr)

         //==============================================================================
         // Current controller
         if(ControlMode == STAND_ALONE_MODE)
         {

             pi_curr_id.Kp = KP_CURR_LOOP_STAND_ALONE;
             pi_curr_id.Ki = KI_CURR_LOOP_STAND_ALONE;

             pi_curr_iq.Kp = KP_CURR_LOOP_STAND_ALONE;
             pi_curr_iq.Ki = KI_CURR_LOOP_STAND_ALONE;

             pi_curr_id.REF      = pi_volt_Usd.OUT;

             pi_curr_iq.REF      = pi_volt_Usq.OUT;

         }
         else // Grid connected
         {
             pi_curr_id.Kp = KP_CURR_LOOP_GRID_CONNECTED;
             pi_curr_id.Ki = KI_CURR_LOOP_GRID_CONNECTED;

             pi_curr_iq.Kp = KP_CURR_LOOP_GRID_CONNECTED;
             pi_curr_iq.Ki = KI_CURR_LOOP_GRID_CONNECTED;

             pi_curr_id.REF      = pi_volt_Udc.OUT;

             pi_curr_iq.REF      = CpuToCLA.IqRef;

         }

         pi_curr_id.INPUT    = park_curr.d;
         pi_curr_id.ERROR    = pi_curr_id.REF - pi_curr_id.INPUT;
         PI_NORMAL_MACRO(pi_curr_id);

         pi_curr_iq.INPUT    = park_curr.q;
         pi_curr_iq.ERROR    = pi_curr_iq.REF - pi_curr_iq.INPUT;
         PI_NORMAL_MACRO(pi_curr_iq);

         // ------------------------------------------------------------------------------
         //  IPARK volt

         if(ControlMode == STAND_ALONE_MODE)
         {
             ipark_voltref.d = pi_curr_id.OUT;
             ipark_voltref.q = pi_curr_iq.OUT;

             ipark_voltref.sine = CLAsinPU(rg_har_1st.Out);
             ipark_voltref.cos  = CLAcosPU(rg_har_1st.Out);

         }
         else // Grid connected
         {
             ipark_voltref.d = pi_curr_id.OUT  + filter_Usd.Vout;
             ipark_voltref.q = pi_curr_iq.OUT  + filter_Usq.Vout;

             ipark_voltref.sine = CLAsinPU(pll_3phase.Theta_har_1st);
             ipark_voltref.cos  = CLAcosPU(pll_3phase.Theta_har_1st);
         }

         iPARK_CLA_MACRO(ipark_voltref)

         // ------------------------------------------------------------------------------
         //   Uapha, Ubeta ---> Ua, Ub, Uc
         // ------------------------------------------------------------------------------

         UabtoUabc.Ualpha = ipark_voltref.alpha;
         UabtoUabc.Ubeta = ipark_voltref.beta;
         UABtoUabc_CLA_MACRO(UabtoUabc);

         //----------------------------------------------------------------------------
         //   Harmonic 3rd
         //----------------------------------------------------------------------------

         Us = CLAsqrt(ipark_voltref.d*ipark_voltref.d + ipark_voltref.q*ipark_voltref.q);

         if(ControlMode == STAND_ALONE_MODE) Us_har_3rd = 0.16*Us*CLAcosPU(rg_har_3rd.Out + 0.5);
         else // Grid connected
         {
             Us_har_3rd = 0.16*Us*CLAcosPU(pll_3phase.Theta_har_3rd + 0.5);
         }

         //----------------------------------------------------------------------------
         //   SinPWM
         //----------------------------------------------------------------------------

         Sinpwm.Ua   = UabtoUabc.Ua + Us_har_3rd;
         Sinpwm.Ub   = UabtoUabc.Ub + Us_har_3rd;
         Sinpwm.Uc   = UabtoUabc.Uc + Us_har_3rd;
         Sinpwm.Udc   = adc_filter.Udc;
         SPWM_T_TYPE_CLA_MARCO(Sinpwm);

         // ------------------------------------------------------------------------------
         //  Connect inputs of the PWM_DRV module and call the PWM signal generation macro
         // ------------------------------------------------------------------------------
         pwm.MfuncA1 = Sinpwm.Ta1;
         pwm.MfuncA2 = Sinpwm.Ta2;

         pwm.MfuncB1 = Sinpwm.Tb1;
         pwm.MfuncB2 = Sinpwm.Tb2;

         pwm.MfuncC1 = Sinpwm.Tc1;
         pwm.MfuncC2 = Sinpwm.Tc2;

         PWM_3T_MACRO(pwm);

         //------------------------------------------------------------------------------------

         if(pi_volt_Usd.OUT > 0.99 || pi_volt_Usd.OUT < -0.99)controller_error_volt_Usd++;
         else controller_error_volt_Usd = 0;

         if(pi_volt_Usq.OUT > 0.99 || pi_volt_Usq.OUT < -0.99) controller_error_volt_Usq++;
         else controller_error_volt_Usq = 0;

         if(pi_volt_Udc.OUT > 0.99 || pi_volt_Udc.OUT < -0.99)controller_error_volt++;
         else controller_error_volt = 0;

         if(pi_curr_id.OUT > 0.99 || pi_curr_id.OUT < -0.99)controller_error_curr_isd++;
         else controller_error_curr_isd = 0;

         if(pi_curr_id.OUT > 0.99 || pi_curr_id.OUT < -0.99) controller_error_curr_isq++;
         else controller_error_curr_isq = 0;

         if(controller_error_curr_isd > 100 || controller_error_curr_isq > 100) ClaToCPU.MEASUARE_CPU.Currflag = 1;
         if(controller_error_volt_Usd > 100 || controller_error_volt_Usq > 100 || controller_error_volt > 100)
         ClaToCPU.MEASUARE_CPU.Voltflag = 1;

    #endif

    }

    else
    {
        test = 1;

    //=========================================================================
    //   Ngat phat xung PWM
    // ========================================================================
    EPwm1Regs.DBCTL.bit.OUT_MODE = 0; // disabled Dead Band
    EPwm2Regs.DBCTL.bit.OUT_MODE = 0; // disabled Dead Band
    EPwm3Regs.DBCTL.bit.OUT_MODE = 0; // disabled Dead Band
    EPwm4Regs.DBCTL.bit.OUT_MODE = 0; // disabled Dead Band

    EPwm1Regs.AQCTLA.bit.CAU = AQ_CLEAR;
    EPwm1Regs.AQCTLA.bit.CAD = AQ_SET;

    EPwm2Regs.AQCTLA.bit.CAU = AQ_CLEAR;
    EPwm2Regs.AQCTLA.bit.CAD = AQ_SET;

    EPwm3Regs.AQCTLA.bit.CAU = AQ_CLEAR;
    EPwm3Regs.AQCTLA.bit.CAD = AQ_SET;

    EPwm4Regs.AQCTLA.bit.CAU = AQ_CLEAR;
    EPwm4Regs.AQCTLA.bit.CAD = AQ_SET;

    EPwm1Regs.CMPA.bit.CMPA = 0;                // Set compare A value : PWM1A -> muc 0
    EPwm1Regs.CMPB.bit.CMPB = 0;                // Set Compare B value : PWM1B   -> muc 0

    EPwm2Regs.CMPA.bit.CMPA = 0;                // Set compare A value: PWM1A -> muc 0
    EPwm2Regs.CMPB.bit.CMPB = 0;                // Set Compare B value 0

    EPwm3Regs.CMPA.bit.CMPA = 0;                // Set compare A value: PWM1A -> muc 0
    EPwm3Regs.CMPB.bit.CMPB = 0;                // Set Compare B value

    EPwm4Regs.CMPA.bit.CMPA = 0;                // Set compare A value : PWM1A -> muc 0
    EPwm4Regs.CMPB.bit.CMPB = 0;                // Set Compare B value : PWM1B   -> muc 0

    //=========================================================================
    //  RESET cac bien
    // ========================================================================
    count_start_CL = 1;
    loop_volt_Udc = 10;
    ramp_switch = 1;    // 0: Level 3 chay Set Duty --- 1: Chay cac truong hop thong thuong
//    loop_volt_Us = 10;

//    controller_error_volt = 0;
//    controller_error_volt_Usd = 0;
//    controller_error_volt_Usq = 0;
//    controller_error_curr_isd = 0;
//    controller_error_curr_isq = 0;


    ClaToCPU.MEASUARE_CPU.Currflag = 0;
    ClaToCPU.MEASUARE_CPU.Voltflag = 0;

    //=========================================================================
    //  RESET cac bien trong thuat toan
    // ========================================================================
    //---------------------------
    rg_har_1st.Angle = 0;
    rg_har_1st.Out = 0;
    Set_ramp.Out = 0.01;

    //---------------------------
    rc_Ref.SetpointValue = 0;

    //---------------------------
    pi_volt_Udc.OUT_I = 0; pi_volt_Udc.OUT = 0;

    pi_volt_Usd.OUT_I = 0; pi_volt_Usd.OUT = 0;
    pi_volt_Usq.OUT_I = 0; pi_volt_Usq.OUT = 0;

    pi_curr_id.OUT_I = 0; pi_curr_id.OUT = 0;
    pi_curr_iq.OUT_I = 0; pi_curr_iq.OUT = 0;
    pi_curr_iz.OUT_I = 0; pi_curr_iz.OUT = 0;

//   rc_Compen.SetpointValue = 0;
//    SoftStop = 0;
//    StopFlag = 0;

    }

    #if (CLA_DEBUG==1)
    __mdebugstop();
    #endif
    }
    else
    {
        test = 2;

        //=========================================================================
        //   Ngat phat xung PWM
        // ========================================================================
        EPwm1Regs.DBCTL.bit.OUT_MODE = 0; // disabled Dead Band
        EPwm2Regs.DBCTL.bit.OUT_MODE = 0; // disabled Dead Band
        EPwm3Regs.DBCTL.bit.OUT_MODE = 0; // disabled Dead Band
        EPwm4Regs.DBCTL.bit.OUT_MODE = 0; // disabled Dead Band

        EPwm1Regs.AQCTLA.bit.CAU = AQ_CLEAR;
        EPwm1Regs.AQCTLA.bit.CAD = AQ_SET;

        EPwm2Regs.AQCTLA.bit.CAU = AQ_CLEAR;
        EPwm2Regs.AQCTLA.bit.CAD = AQ_SET;

        EPwm3Regs.AQCTLA.bit.CAU = AQ_CLEAR;
        EPwm3Regs.AQCTLA.bit.CAD = AQ_SET;

        EPwm4Regs.AQCTLA.bit.CAU = AQ_CLEAR;
        EPwm4Regs.AQCTLA.bit.CAD = AQ_SET;

    //    EPwm1Regs.CMPA.bit.CMPA = 0;                // Set compare A value : PWM1A -> muc 0
    //    EPwm1Regs.CMPB.bit.CMPB = 0;                // Set Compare B value : PWM1B   -> muc 0
    //
    //    EPwm2Regs.CMPA.bit.CMPA = 0;                // Set compare A value: PWM1A -> muc 0
    //    EPwm2Regs.CMPB.bit.CMPB = 0;                // Set Compare B value 0
    //
    //    EPwm3Regs.CMPA.bit.CMPA = 0;                // Set compare A value: PWM1A -> muc 0
    //    EPwm3Regs.CMPB.bit.CMPB = 0;                // Set Compare B value
    //
    //    EPwm4Regs.CMPA.bit.CMPA = 0;                // Set compare A value : PWM1A -> muc 0
    //    EPwm4Regs.CMPB.bit.CMPB = 0;                // Set Compare B value : PWM1B   -> muc 0
        //pwm.periodMax = 1000;
        EPwm1Regs.CMPA.bit.CMPA = 0;                // Set compare A value : PWM1A -> muc 0
        EPwm1Regs.CMPB.bit.CMPB = 1000;    // Set Compare B value : PWM1B   -> muc 0

        EPwm2Regs.CMPA.bit.CMPA = 0;                // Set compare A value: PWM1A -> muc 0
        EPwm2Regs.CMPB.bit.CMPB = 1000;    // Set Compare B value 0

        EPwm3Regs.CMPA.bit.CMPA = 0;                // Set compare A value: PWM1A -> muc 0
        EPwm3Regs.CMPB.bit.CMPB = 1000;    // Set Compare B value

        EPwm4Regs.CMPA.bit.CMPA = 0;                // Set compare A value : PWM1A -> muc 0
        EPwm4Regs.CMPB.bit.CMPB = 1000;    // Set Compare B value : PWM1B   -> muc 0
    }
}

interrupt void Cla1Task2 (void) {}
interrupt void Cla1Task3 (void) {}
interrupt void Cla1Task4 (void) {}
interrupt void Cla1Task5 (void) {}
interrupt void Cla1Task6 (void) {}
interrupt void Cla1Task7 (void) {}
interrupt void Cla1Task8 (void) {
    #if (CLA_DEBUG==1)
    //__mdebugstop();
    #endif

    //-----------------------------
    ControlMode = GRID_CONNECTED_MODE;

    //======================================================

    CLARKE_3PHASE_CLA_INIT(clarke_curr)
    clarke_volt  = clarke_curr;
    clarke_volt_pll = clarke_curr;

    //=====================================================
    // PLL GRID VOLTAGE
//    pll_3phase.Kp = KP_PLL;
//    pll_3phase.Ki = KI_PLL;
//    pll_3phase.Ts = T;
//    pll_3phase.IN_MAX = Us_max;
//    pll_3phase.OUT_MAX = Wmax;
//    pll_3phase.wref1    = 1.0*Wref/Wmax;
//    pll_3phase.wref3    = 3.0*Wref/Wmax;
//
//    pll_3phase.Usq = 0;
//    pll_3phase.Theta_har_1st = 0;
//    pll_3phase.Theta_har_3rd = 0;
//    pll_3phase.Kp_dsp = 0;
//    pll_3phase.Ki_dsp = 0;
//    pll_3phase.w_P = 0;
//    pll_3phase.w_I = 0;
//    pll_3phase.w = 0;
//    pll_3phase.w1 = 0;
//    pll_3phase.w3 = 0;
//    pll_3phase.CheckPhase = 0;

    //======================================================
    PARK_CLA_INIT(park_curr)
    park_volt = park_curr;
    park_volt_pll = park_curr;
    iPARK_CLA_INIT(ipark_voltref)

    //================================================================
    RAMP_GEN_CLA_INIT(Set_ramp)
    Set_ramp.Out = 0.001;

    //================================================================
   SVM3D_DQZ_GEN_CLA_INT_1(Svm3d)
//    RSPWM_GEN_CLA_INT(Rspwm)

    //================================================================
    pwm.PeriodMax = (FREQUENCY_CLOCK_PWM/(2*SVM_SYSTEM)); /* Initializa ePWM */
    //=================================================================
    // Ramp Step

#if(BUILDLEVEL == LEVEL1)
    //================================================================
    RAMP_GEN_CLA_INIT(rg_har_1st)
    rg_har_1st.StepAngleMax = BASE_FREQ*T;

    //================================================================
    RC_INT_MACRO(rc_Ref)
    rc_Ref.StepRampDec = 0.001/Us_max;
    rc_Ref.StepRampInc = 0.001/Us_max;
#endif

#if(BUILDLEVEL == LEVEL2)
    //================================================================
    RAMP_GEN_CLA_INIT(rg_har_1st)
    rg_har_1st.StepAngleMax = BASE_FREQ*T;

    RAMP_GEN_CLA_INIT(rg_har_3rd)
    rg_har_3rd.StepAngleMax = BASE_FREQ*T;

    //================================================================
    RC_INT_MACRO(rc_Ref)
    rc_Ref.StepRampDec = 0.01/Us_max;
    rc_Ref.StepRampInc = 0.01/Us_max;
#endif

#if(BUILDLEVEL == LEVEL3)
    //================================================================
    RAMP_GEN_CLA_INIT(rg_har_1st)
    rg_har_1st.StepAngleMax = BASE_FREQ*T;

    //================================================================
    RC_INT_MACRO(rc_Ref)
    rc_Ref.StepRampDec = 0.01/Is_max;
    rc_Ref.StepRampInc = 0.01/Is_max;

#endif

#if(BUILDLEVEL == LEVEL4)
    //================================================================
    RAMP_GEN_CLA_INIT(rg_har_1st)
    rg_har_1st.StepAngleMax = BASE_FREQ*T;

//    RAMP_GEN_CLA_INIT(rg_har_3rd)
//    rg_har_3rd.StepAngleMax = BASE_FREQ*T;

    //================================================================
    RC_INT_MACRO(rc_Ref)
    rc_Ref.StepRampDec = (0.0005/1)/Us_max;
    rc_Ref.StepRampInc = (0.0005/1)/Us_max;

    rc_Compen.StepRampDec = 0.05*T;
    rc_Compen.StepRampInc = 0.05*T;

#endif

#if(BUILDLEVEL == LEVEL5)
    //================================================================
    rc_Ref.StepRampDec = 0.00005/Is_max;
    rc_Ref.StepRampInc = 0.00005/Is_max;
#endif

#if(BUILDLEVEL == LEVEL6)
    //================================================================
    rc_Ref.StepRampDec = 0.005/Udc_max;
    rc_Ref.StepRampInc = 0.005/Udc_max;
#endif

#if(BUILDLEVEL == LEVELALL)

    //================================================================
    RAMP_GEN_CLA_INIT(rg_har_1st)
    rg_har_1st.StepAngleMax = BASE_FREQ*T;

//    RAMP_GEN_CLA_INIT(rg_har_3rd)
//    rg_har_3rd.StepAngleMax = BASE_FREQ*T;

    rg_har_3rd = rg_har_1st;

    //================================================================
    RC_INT_MACRO(rc_Ref)
    // Grid connected
    rc_Ref.StepRampDec = 0.1/Udc_max;
    rc_Ref.StepRampInc = 0.1/Udc_max;

#endif

    //=================================================================
    // PI Controller

#if(BUILDLEVEL == LEVEL3)
    // Current controller
    PI_NORMAL_INT(pi_curr_id)
    pi_curr_id.Ts = (float)Ti;
    pi_curr_id.Kp = KP_CURR_LOOP;
    pi_curr_id.Ki = KI_CURR_LOOP;
    pi_curr_id.IN_max   = (float)Is_max;
    pi_curr_id.OUT_max  = (float)Us_max;

    PI_NORMAL_INT(pi_curr_iq)
    pi_curr_iq.Ts = (float)Ti;
    pi_curr_iq.Kp = KP_CURR_LOOP;
    pi_curr_iq.Ki = KI_CURR_LOOP;
    pi_curr_iq.IN_max   = (float)Is_max;
    pi_curr_iq.OUT_max  = (float)Us_max;

    PI_NORMAL_INT(pi_curr_iz)
    pi_curr_iz.Ts = (float)Ti;
    pi_curr_iz.Kp = KP_CURR_LOOP_Z;
    pi_curr_iz.Ki = KI_CURR_LOOP_Z;
    pi_curr_iz.IN_max   = (float)Is_max;
    pi_curr_iz.OUT_max  = (float)Us_max;

#endif

#if(BUILDLEVEL == LEVEL4)
    loop_volt_Us = 0;
    //----------------------------------------------------
    // Current controller
    PI_NORMAL_INT(pi_curr_id)
    pi_curr_id.Ts = (float)Ti;
    pi_curr_id.Kp = KP_CURR_LOOP_1;
    pi_curr_id.Ki = KI_CURR_LOOP_1;
//    pi_curr_id.Kp = KP_CURR_LOOP;
//    pi_curr_id.Ki = KI_CURR_LOOP;
    pi_curr_id.IN_max   = (float)Is_max;
    pi_curr_id.OUT_max  = (float)Us_max;

    PI_NORMAL_INT(pi_curr_iq)
    pi_curr_iq.Ts = (float)Ti;
    pi_curr_iq.Kp = KP_CURR_LOOP_1;
    pi_curr_iq.Ki = KI_CURR_LOOP_1;
//    pi_curr_iq.Kp = KP_CURR_LOOP;
//    pi_curr_iq.Ki = KI_CURR_LOOP;
    pi_curr_iq.IN_max   = (float)Is_max;
    pi_curr_iq.OUT_max  = (float)Us_max;

    PI_NORMAL_INT(pi_curr_iz)
    pi_curr_iz.Ts = (float)Ti;
    pi_curr_iz.Kp = KP_CURR_LOOP_1;
    pi_curr_iz.Ki = KI_CURR_LOOP_1;
//    pi_curr_iz.Kp = KP_CURR_LOOP;
//    pi_curr_iz.Ki = KI_CURR_LOOP;
    pi_curr_iz.IN_max   = (float)Is_max;
    pi_curr_iz.OUT_max  = (float)Us_max;

    //----------------------------------------------------
    // Voltage controller
    PI_NORMAL_INT(pi_volt_Usd)
    pi_volt_Usd.Ts = (float)T_Us;
    pi_volt_Usd.Kp = KP_VOLT_US_LOOP;
    pi_volt_Usd.Ki = KI_VOLT_US_LOOP;
    pi_volt_Usd.IN_max   = (float)Us_max;
    pi_volt_Usd.OUT_max  = (float)Is_max;

    PI_NORMAL_INT(pi_volt_Usq)
    pi_volt_Usq.Ts = (float)T_Us;
    pi_volt_Usq.Kp = KP_VOLT_US_LOOP;
    pi_volt_Usq.Ki = KI_VOLT_US_LOOP;
    pi_volt_Usq.IN_max   = (float)Us_max;
    pi_volt_Usq.OUT_max  = (float)Is_max;

#endif

#if(BUILDLEVEL == LEVEL5)
    //----------------------------------------------------
    // Current controller
    PI_NORMAL_INT(pi_curr_id)
    pi_curr_id.Ts = (float)Ti;
    pi_curr_id.Kp = KP_CURR_LOOP;
    pi_curr_id.Ki = KI_CURR_LOOP;
    pi_curr_id.IN_max   = (float)Is_max;
    pi_curr_id.OUT_max  = (float)Us_max;

    PI_NORMAL_INT(pi_curr_iq)
    pi_curr_iq.Ts = (float)Ti;
    pi_curr_iq.Kp = KP_CURR_LOOP;
    pi_curr_iq.Ki = KI_CURR_LOOP;
    pi_curr_iq.IN_max   = (float)Is_max;
    pi_curr_iq.OUT_max  = (float)Us_max;

    PI_NORMAL_INT(pi_curr_iz)
    pi_curr_iz.Ts = (float)Ti;
    pi_curr_iz.Kp = KP_CURR_LOOP_Z;
    pi_curr_iz.Ki = KI_CURR_LOOP_Z;
    pi_curr_iz.IN_max   = (float)Is_max;
    pi_curr_iz.OUT_max  = (float)Us_max;

#endif

#if(BUILDLEVEL == LEVEL6)

    //----------------------------------------------------
    // Current controller
    PI_NORMAL_INT(pi_curr_id)
    pi_curr_id.Ts = (float)Ti;
    pi_curr_id.Kp = KP_CURR_LOOP;
    pi_curr_id.Ki = KI_CURR_LOOP;
    pi_curr_id.IN_max   = (float)Is_max;
    pi_curr_id.OUT_max  = (float)Us_max;

    pi_curr_iq = pi_curr_id;
    pi_curr_iq.Ts = (float)Ti;
    pi_curr_iq.Kp = KP_CURR_LOOP;
    pi_curr_iq.Ki = KI_CURR_LOOP;
    pi_curr_iq.IN_max   = (float)Is_max;
    pi_curr_iq.OUT_max  = (float)Us_max;

    pi_curr_iz = pi_curr_id;
    pi_curr_iz.Ts = (float)Ti;
    pi_curr_iz.Kp = KP_CURR_LOOP_Z;
    pi_curr_iz.Ki = KI_CURR_LOOP_Z;
    pi_curr_iz.IN_max   = (float)Is_max;
    pi_curr_iz.OUT_max  = (float)Us_max;

    // Voltage controller
    PI_NORMAL_INT(pi_volt_Udc)
    pi_volt_Udc.Ts = T_Udc;
    pi_volt_Udc.Kp = KP_VOLT_UDC_LOOP;
    pi_volt_Udc.Ki = KI_VOLT_UDC_LOOP;
    pi_volt_Udc.IN_max   = (float)Udc_max;
    pi_volt_Udc.OUT_max  = (float)Is_max;

#endif

#if(BUILDLEVEL == LEVELALL)

    //----------------------------------------------------
    // Current controller

    PI_NORMAL_INT(pi_curr_id)
    // Grid connected
    pi_curr_id.Kp = KP_CURR_LOOP_GRID_CONNECTED;
    pi_curr_id.Ki = KI_CURR_LOOP_GRID_CONNECTED;

    pi_curr_id.Ts = Ti;
    pi_curr_id.IN_max   = Is_max;
    pi_curr_id.OUT_max  = Us_max;

    pi_curr_iq = pi_curr_id;

    //--------------------------------
    // Voltage controller
    //--------------------------------

    // Stand-alone mode
    PI_NORMAL_INT(pi_volt_Usd)
    pi_volt_Usd.Ts = T_Us;
    pi_volt_Usd.Kp = KP_VOLT_US_LOOP;
    pi_volt_Usd.Ki = KI_VOLT_US_LOOP;
    pi_volt_Usd.IN_max   = Us_max;
    pi_volt_Usd.OUT_max  = Is_max;

    pi_volt_Usq = pi_volt_Usd;

    // Grid-connected mode
    PI_NORMAL_INT(pi_volt_Udc)
    pi_volt_Udc.Ts = T_Udc;
    pi_volt_Udc.Kp = KP_VOLT_UDC_LOOP;
    pi_volt_Udc.Ki = KI_VOLT_UDC_LOOP;
    pi_volt_Udc.IN_max   = Udc_max;
    pi_volt_Udc.OUT_max  = Is_max;

#endif

    //================================================================
//    // Grid voltage
//   CALCULATOR_RMS_PV_CLA_INIT(Calculator_Rms);
//   Calculator_Rms.nsamplesTB = (1.0/NORMAL_FREQ)*ISR_FREQUENCY;

    //=================================================================
    // Filter ADC

    LOWPASSFILTER_INT(filter_Udc)
    filter_Udc.Heso_out = 0.96;
    filter_Udc.Heso_in = 0.04;

    filter_Usd = filter_Udc;
    filter_Usq = filter_Udc;

//    LOWPASSFILTER_INT(filter_VaG)
//    LOWPASSFILTER_INT(filter_VbG)
//    LOWPASSFILTER_INT(filter_VcG)
//
//    filter_VaG.Heso_out = 0.1373;
//    filter_VaG.Heso_in = 0.8627;
//
//    filter_VbG = filter_VaG;
//    filter_VcG = filter_VaG;

/*
    filter_VaG.Heso_out = 1.0/(1.0 + 0.0001*2*PI*10000);
    filter_VaG.Heso_in = 1.0 - filter_VaG.Heso_out;
    Heso_in = deltaT/(RC +deltaT)
    Heso_out = RC/(RC + deltaT)
    fc = 1/(2*pi*RC)
    RC = 1/(2*pi*fc) = 1.0
    fc = 0.16kHz = 160Hz
*/

    //================================================================================================
    // Khoi tao cac bien
    OffsetCalCounter = 0;
    IsrTicker = 0;
    START_ADC = 2;

    count_start_CL = 1;
    loop_volt_Udc = 10;
    ramp_switch = 1;    // 0: Level 3 chay Set Duty --- 1: Chay cac truong hop thong thuong

    switch_bdk = 0;
    test = 0;
//    loop_volt_Us = 10;
//
//    point_start = 0;
//    controller_error_volt = 0;
//    controller_error_volt_Usd = 0;
//    controller_error_volt_Usq = 0;
//    controller_error_curr_isd = 0;
//    controller_error_curr_isq = 0;

//    SoftStop = 0;
//    StopFlag = 0;

    /**********************************************************/
    __mnop();
    __mnop();
    __mnop();
}
